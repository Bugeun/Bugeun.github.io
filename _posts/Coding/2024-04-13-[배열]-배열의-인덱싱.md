---
title: "[배열] 배열의 인덱싱"
date: 2024-04-13
categories: Coding
---

다차원 배열의 경우 행과 열이 있다.

[0][0] | [0][1]  
---|---  
[1][0] | [1][1]  
  
그러나 어셈블리에선 이걸 일렬로 인덱싱한다. 어떻게 접근할 수 있을까?

행을 x로 열을 y로 두자. 그렇게 되면 어셈블리에서 인덱싱은 [2* x +y]가 된다.

그럼 각각 아래의 표와 같이 인덱싱 될 수 있다. 여기서 2는 y의 array의 최대 크기가 된다.

0 | 1  
---|---  
2 | 3  
      
    
    #include<stdio.h>
    
    
    
    int arr[2][2] = {0,};
    
    int main(){
    
    for(int x = 0; x < 2; ++x)
    {
    	for(int y = 0; y < 2; ++y)
        {
        
    		arr[x][y] = 2 * x + y; 
            printf("%d",arr[x][y]); 
    		
    	}
        printf("\n");	
    }
    
    }

이제 어셈블리를 한번 보자 우선 C언어 코드로 DFS 알고리즘의 선을 만드는 함수를 만들어보겠다.

    
    
    #include <stdio.h>
    
    #define MAX_VERTEX 10
    int VERTEX[MAX_VERTEX][MAX_VERTEX];
    
    int link_vertex(int start_n, int end_n){
    
    VERTEX[start_n][end_n] = 1; 
    
    }
    
    int main(){
    
    	link_vertex(1,2);
    }

함수 이름은 link_vertex이며 파라미터를 지정받아 배열 위치 값을 1로 초기화하는 함수이다. 이것을 어셈블리로 어떻게 만들어 볼 수
있을까?

    
    
    section .text
    
    section .data
    
    	VERTEX resd 100 
    
    link_vertex:
    
    	push rbp
        mov rbp, rsp
        sub rsp, 12 
        mov DWORD PTR [rbp-4], edi
        mov DWORD PTR [rbp-8], esi
        mov eax, DWORD PTR [rbp-8]
        mov rcx, eax
        mov eax, DWORD PTR [rbp-4] 
        mov rdx, eax
        mov rax, rdx; 여기부터 인덱싱 계산
        sal rax, 2 
        add rax, rdx
        add rax, rax
        add rax, rcx
        mov DWORD VERTEX[0+rax*4], 1
        
    
    _start:
    
    	push rbp
        mov rbp, rsp 
        sub rsp, 12
        mov edi, 1
        mov esi, 2 
        call link_vertex

다음과 같은 코드가 될 수 있다. 각 인자를 edi,esi에 담고 인자를 전달한다. (참고로 64비트에서도 데이터 크기가 작은 경우 최적화를
위해 32비트 레지스터를 사용하여 콜링 컨벤션을 한다.)

그 후 link_vertex를 보면 주석으로 "여기서부터 계산"이라고 적힌 것을 볼 수 있는데, 이걸 해석해보면

우선 rbp-4를 x로 rbp-8을 y로 두겠다.

rax는 rdx(rbp-4)가 들어있으므로 x * 4가 된다. 그 결과에 rax를 한번 더 더하므로 *2가 되고 또 그 결과에
rcx(rbp-8)를 더하므로 +y가 된다 그 후 VERTEX[index]에 index * 4를 해주므로 식을 쓰자면 아래와 같다.

더보기

((((x*4) + x) * 2) + y) * 4 = 1

이걸 풀어보면 결국 아래와 같다.

더보기

VERTEX[40 * x + 4y] = 1

(참고로 = 1 은 대입 연산자를 의미한다.)

4를 나눠보면 10 * x + y가 되므로 위에서 인덱싱했던 배열 오프셋과 일치함을 볼 수 있다.

(참고로 4가 전체적으로 곱해진 이유는 int형으로 4바이트를 곱해야하기 때문이다.)

10을 곱해진 이유는 위에서 설명했듯 Y의 최대 크기가 10이기 때문이다.

