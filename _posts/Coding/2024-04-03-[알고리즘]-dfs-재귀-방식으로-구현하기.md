---
title: "[알고리즘] DFS 재귀 방식으로 구현하기"
date: 2024-04-03
categories: Coding
---


    #include <stdio.h>
    
    #define MAX_VERTEX 10
    
    
    int VERTEX[MAX_VERTEX][MAX_VERTEX];
    int wall[MAX_VERTEX];
    
    
    int link_vertex(int start_n, int end_n){
    
    if(start_n<=0||end_n<=0)
    {
        printf("invaild date");
    }
    
    VERTEX[start_n][end_n] = 1;
    VERTEX[end_n][start_n] = 1;
    
    return 0;
    
    }
    
    
    int DFS(int n, int end){
    
    wall[n] = 1;
    
    for(int start=1; start<end; start++){
        if (VERTEX[n][start]==1 && wall[start]==0){
    
            printf("%d",start);
            DFS(start,end);
            }
    
    }
    }
    
    
    int main(){
    
    
        link_vertex(1,2);
        link_vertex(2,4);
        link_vertex(4,8);
        link_vertex(1,3);
        link_vertex(3,5);
        link_vertex(5,7);
    
        int start = 1;
        printf("%d", start);
        DFS(start, 10);
    
    }

**DFS 알고리즘이란?**

깊이 우선 탐색 알고리즘으로서 모든 노드들을 순차적으로 한번씩 탐색한다. 탐색 방식은 아래 그림에서 1번과 인접해있는 노드에 접근하고 그
다음 번호에 인접해있는 노드에 접근하며 더 이상 인접해있는 노드가 없는 경우 다시 빠져나와 1번부터 다시 시작하게 된다. 이러한 알고리즘을
구현하려면 각 노드에 대해 서브 루틴을 순차적으로 생성시켜야 하는데, 그러한 방식엔 두 가지 방법이 있다.

1\. 재귀 호출

2\. 스택 사용

재귀 호출을 하면 자연스럽게 자신과 같은 서브루틴의 스택을 하나 형성하기 때문에 사실 1번과 2번은 비슷하다.

그 후 각 노드에 인접해있는 노드를 탐색시켜 다음 노드로 이동하게 한 후 만약 인접해있는 노드가 없을 경우 루틴을 종료시키고 (이 때 스택을
사용하는 방식은 해당 노드를 POP 하게 될 것 이다.) 다시 처음으로 돌아와 탐색하게 된다.

.

![](https://blog.kakaocdn.net/dn/cTJeHP/btsGmWBNZbL/1TBbWG8lEQkgI8dUxbWww0/img.png)DFS
알고리즘 설명

본 코드에선 각 노드를 잇는 link_vertex() 함수를 만들고 DFS() 함수를 통해 증명한다. 결과는 아래와 같다.

(결과는 위 그림과 상관없다. 본 코드에서 link_vertex()로 연결한 노드에 대한 결과이다.)

![](https://blog.kakaocdn.net/dn/d6OvJE/btsGlT6UQay/LoJpC3XintwqeEesFWvnq1/img.png)

