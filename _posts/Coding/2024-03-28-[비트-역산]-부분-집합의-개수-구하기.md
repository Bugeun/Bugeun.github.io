---
title: "[비트 역산] 부분 집합의 개수 구하기"
date: 2024-03-28
categories: Coding
---

**문제)**

집합의 크기 n을 입력받고 n에서 나올 수 있는 모든 부분집합의 개수를 구하고 임의의 원소들을 출력하라.

(* 단, 비트 연산으로 구해야한다.)

**문제 풀이)**

원소의 개수를 n으로 둔다. 여기서 모든 부분집합이 나올 갯수는 2^n이 된다.

물론 공집합도 포함이 되어야 한다. (공집합은 모든 집합의 부분집합이다. 이를 귀류법으로 증명이 가능하다.)

우선 집합의 크기 n으로 2의 n승을 비트연산으로 만들려면 1을 n번 LSL(Left Shift Logical)하면 된다.

    
    
    (1<<n)

예로들어 10진수 1은 2진수 01이다. 이것을 한번 쉬프트하면 10 즉, 2가 된다.

2는 2^1이다. 10진수 2는 다시 2진수 10이 되고 이것을 한번 쉬프트하면 100 즉, 4가 된다.

4는 2^2이다. 즉 1을 두 번 LSL하면 4가 된다. (아래 사진에 3은 실수로 넣었다.)

결국 왼쪽 쉬프트는 한번 할 때 마다 2의 제곱이 되고 결과적으로 2^n에서 쉬프트 할 때 마다 (n+1)이 된다.

그렇다는건 4를 넣으면 2^4가 된다는 뜻이다.

![](https://blog.kakaocdn.net/dn/cyIYRM/btsGaXOwtfK/yj9VNH5LGxhu41EoM5YiG0/img.png)

그럼 지금까지의 코드를 써보자면 아래와 같다.

    
    
    n = input()
    
    for i in range(1<<n)

부분 집합이 나올 갯수는 구했으니 이제 부분집합의 원소들을 출력할 차례이다.

각 원소들은 list로 넣어서 append()를 시킬 것이므로 아래와 같이 선언해준다.

(subset_list = []로 시작한 이유는 공집합도 포함시켜야 하기 때문이다.)

    
    
    n = input()
    
    result_list = []
    
    for i in range(1<<n):
    	subset_list = []

이제 각 원소값(만약 n이 3일 경우 0,1,2가 된다.) i의 x번째 비트가 1인지 검사한다. 우선 공집합을 넣기 위해
subset_list = []를 먼저 선언해준다. i의 x번째 비트에 1이 없는 경우 x엔 0이 들어가고 1이 들어갈 수 있는 모든 경우의
수를 출력한다.

아래 코드를 보면 1을 x번 쉬프트 해주면서 & 연산으로 i의 비트를 검사 해줄 수 있다. n이 2이라고 가정했을 경우 0001, 0010을
순회하면서 각 자리수의 비트를 검사해준다. 만약 해당 자리에 1이 없는 경우 if not이 되면서 넘어간다.

만약 n이 2이고 i가 3인 경우 0011이고 0001(x = 0),0010(x=1) 이 들어간다. x가 0~1을 순회하므로 사실상 모든
원소가 들어가는 것이다.

    
    
    n = input()
    
    result_list = []
    
    for i in range(1<<n):
    	subset_list = []
    	for x in range(n):
    		if i & (1<<x):
            	subset_list.append(x)
    	result_list.append(subset_list)
    
    print(result_list)

아래 처럼 정리해서 보면 편하다.

![](https://blog.kakaocdn.net/dn/dEtSmN/btsF9I6ulGs/F0RoaePr6A5vUL6qxKiwMk/img.png)

